import { Modality, Type } from "@google/genai";
import { getAiClient } from "./aiClient";
import { logDev } from "./loggingService";

const generateImagePromptsSystemInstruction = `You are a creative image prompt assistant. Based on the user's prompt, generate 5 diverse and detailed alternative prompts exploring different styles and subjects. Respond ONLY with a JSON object: { "suggestions": ["prompt1", "prompt2", ...] }`;

export const generateImagePromptSuggestions = async (basePrompt: string): Promise<string[]> => {
    const ai = getAiClient();
    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: `Generate image prompt suggestions based on this prompt: "${basePrompt}"`,
            config: {
                systemInstruction: generateImagePromptsSystemInstruction,
                responseMimeType: 'application/json',
                responseSchema: {
                    type: Type.OBJECT,
                    properties: {
                        suggestions: {
                            type: Type.ARRAY,
                            items: { type: Type.STRING }
                        },
                    },
                    required: ["suggestions"],
                }
            }
        });
        const jsonText = response.text.trim();
        const result = JSON.parse(jsonText);
        return result.suggestions || [];
    } catch (error) {
        console.error("Error generating image prompt suggestions:", error);
        logDev('error', 'Error in generateImagePromptSuggestions:', error);
        throw error;
    }
};

// Helper to convert blob to base64
const blobToBase64 = (blob: Blob): Promise<string> => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
            if (reader.result) {
                const base64String = (reader.result as string).split(',')[1];
                resolve(base64String);
            } else {
                reject(new Error("FileReader result is null"));
            }
        };
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
};

const getDimensionsFromRatio = (aspectRatio: "1:1" | "16:9" | "9:16" | "4:3" | "3:4"): { width: number, height: number } => {
    const baseWidth = 1024;
    switch (aspectRatio) {
        case "16:9": return { width: baseWidth, height: Math.round(baseWidth * 9 / 16) }; // 576
        case "9:16": return { width: Math.round(baseWidth * 9 / 16), height: baseWidth }; // 576
        case "4:3": return { width: baseWidth, height: Math.round(baseWidth * 3 / 4) }; // 768
        case "3:4": return { width: Math.round(baseWidth * 3 / 4), height: baseWidth }; // 768
        case "1:1":
        default:
            return { width: baseWidth, height: baseWidth };
    }
}

export const generateImage = async (prompt: string, numberOfImages: number, aspectRatio: "1:1" | "16:9" | "9:16" | "4:3" | "3:4"): Promise<{ images: string[] }> => {
    try {
        const { width, height } = getDimensionsFromRatio(aspectRatio);
        const imagePromises: Promise<string>[] = [];

        for (let i = 0; i < numberOfImages; i++) {
            // Add a random seed for variation in each image
            const seed = Math.floor(Math.random() * 100000);
            const url = `https://image.pollinations.ai/prompt/${encodeURIComponent(prompt)}?width=${width}&height=${height}&seed=${seed}&nologo=true`;
            
            const promise = fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`The image generation service returned status ${response.status}. It may be temporarily unavailable.`);
                    }
                    return response.blob();
                })
                .then(blob => blobToBase64(blob));
            
            imagePromises.push(promise);
        }

        const base64Images = await Promise.all(imagePromises);
        
        if (base64Images.length === 0) {
             throw new Error("No images were generated by the service.");
        }

        return { images: base64Images };

    } catch (error) {
        console.error("Error generating image with Pollinations:", error);
        logDev('error', 'Error in generateImage (Pollinations):', error);
        // Throw a user-friendly error to be caught by the UI handler
        throw new Error(error instanceof Error ? error.message : "Failed to generate image due to an unknown error.");
    }
};

export interface EditImageResult {
    editedImageBase64?: string;
    textResponse?: string;
    usageMetadata?: {
        promptTokenCount?: number;
        candidatesTokenCount?: number;
        totalTokenCount?: number;
    };
}

export const editImage = async (prompt: string, image: { base64: string; mimeType: string; }): Promise<EditImageResult> => {
    const ai = getAiClient();
    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image-preview',
            contents: {
                parts: [
                    {
                        inlineData: {
                            data: image.base64,
                            mimeType: image.mimeType,
                        },
                    },
                    { text: prompt },
                ],
            },
            config: {
                responseModalities: [Modality.IMAGE, Modality.TEXT],
            },
        });

        const result: EditImageResult = {
            usageMetadata: response.usageMetadata
        };

        if (response.candidates && response.candidates.length > 0) {
            for (const part of response.candidates[0].content.parts) {
                if (part.text) {
                    result.textResponse = (result.textResponse || "") + part.text;
                } else if (part.inlineData) {
                    result.editedImageBase64 = part.inlineData.data;
                }
            }
        }
        
        if (!result.editedImageBase64 && !result.textResponse) {
             throw new Error("The model did not return an image or text for the edit request.");
        }

        return result;

    } catch (error) {
        console.error("Error editing image:", error);
        logDev('error', 'Error in editImage:', error);
        throw error;
    }
};
